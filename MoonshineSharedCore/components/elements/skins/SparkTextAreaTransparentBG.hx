/**
 *  Generated by mxmlc 4.0
 *
 *  Package:    elements.skins
 *  Class:      SparkTextAreaTransparentBG
 *  Source:     /Users/axgord/dev/Moonshine-IDE/ide/MoonshineSharedCore/src/elements/skins/SparkTextAreaTransparentBG.mxml
 *  Template:   flex2/compiler/mxml/gen/ClassDef.vm
 *  Time:       2019.04.22 23:25:49 MSK
 */

package elements.skins;

import mx.core.FlexVersion;

import flash.accessibility.*;
import flash.debugger.*;
import flash.display.*;
import flash.errors.*;
import flash.events.*;
import flash.external.*;
import flash.geom.*;
import flash.media.*;
import flash.net.*;
import flash.printing.*;
import flash.profiler.*;
import flash.system.*;
import flash.text.*;
import flash.ui.*;
import flash.utils.*;
import flash.xml.*;
import mx.binding.*;
import mx.core.ClassFactory;
import mx.core.DeferredInstanceFromClass;
import mx.core.DeferredInstanceFromFunction;
import mx.core.IDeferredInstance;
import mx.core.IFactory;
import mx.core.IFlexModuleFactory;
import mx.core.IPropertyChangeNotifier;
import mx.core.IStateClient2;
import mx.core.Mx_internal;
import mx.filters.*;
import mx.graphics.SolidColor;
import mx.graphics.SolidColorStroke;
import mx.states.AddItems;
import mx.states.SetProperty;
import mx.states.State;
import mx.styles.*;
import spark.components.Label;
import spark.components.RichEditableText;
import spark.components.Scroller;
import spark.primitives.Rect;
import spark.skins.SparkSkin;

/**
 * @copy spark.skins.spark.ApplicationSkin#hostComponent
 */
@:meta(HostComponent(name = 'spark.components.TextArea'))
@:meta(States(name = 'normal', name = 'disabled', name = 'normalWithPrompt', name = 'disabledWithPrompt'))
//  begin class def
class SparkTextAreaTransparentBG extends spark.skins.SparkSkin implements mx.core.IStateClient2 {

	//  instance variables
	@:meta(Bindable())
	/**
	 * @private
	 **/
	public var border:spark.primitives.Rect;

	@:meta(Bindable())
	/**
	 * @private
	 **/
	public var borderStroke:mx.graphics.SolidColorStroke;

	@:meta(Bindable())
	/**
	 * @private
	 **/
	public var promptDisplay:spark.components.Label;

	@:meta(Bindable())
	/**
	 * @private
	 **/
	public var scroller:spark.components.Scroller;

	@:meta(Bindable())
	/**
	 * @private
	 **/
	public var shadow:spark.primitives.Rect;

	@:meta(Bindable())
	/**
	 * @private
	 **/
	public var textDisplay:spark.components.RichEditableText;

	//  type-import dummies

	//  constructor (Flex display object)
	/**
	 * @private
	 **/
	public function new() {
		super();

		// mx_internal::_document = this;

		// layer initializers

		// properties
		this.blendMode = 'normal';
		this.mxmlContent = [_SparkTextAreaTransparentBG_Rect1_i(), _SparkTextAreaTransparentBG_Rect2_i(), _SparkTextAreaTransparentBG_Scroller1_i()];
		this.currentState = 'normal';

		// events

		var _SparkTextAreaTransparentBG_Label1_factory:DeferredInstanceFromFunction =
		new mx.core.DeferredInstanceFromFunction(_SparkTextAreaTransparentBG_Label1_i);

		states = [
				new State({
					'name': 'normal',
					'overrides': []
				}),
				new State({
					'name': 'disabled',
					'stateGroups': ['disabledStates'],
					'overrides': [
					new mx.states.SetProperty().initializeFromObject({
								'name': 'alpha',
								'value': 0.5
							})
			]
				}),
				new State({
					'name': 'normalWithPrompt',
					'overrides': [
					new AddItems().initializeFromObject({
								'itemsFactory': _SparkTextAreaTransparentBG_Label1_factory,
								'destination': null,
								'propertyName': 'mxmlContent',
								'position': 'after',
								'relativeTo': ['scroller']
							})
			]
				}),
				new State({
					'name': 'disabledWithPrompt',
					'stateGroups': ['disabledStates'],
					'overrides': [
					new AddItems().initializeFromObject({
								'itemsFactory': _SparkTextAreaTransparentBG_Label1_factory,
								'destination': null,
								'propertyName': 'mxmlContent',
								'position': 'after',
								'relativeTo': ['scroller']
							}),
					new mx.states.SetProperty().initializeFromObject({
								'name': 'alpha',
								'value': 0.5
							})
			]
				})
		];

	}

	/**
	 * @private
	 **/
	private var __moduleFactoryInitialized:Bool = false;

	/**
	 * @private
	 * Override the module factory so we can defer setting style declarations
	 * until a module factory is set. Without the correct module factory set
	 * the style declaration will end up in the wrong style manager.
	 **/
	override private function set_moduleFactory(factory:IFlexModuleFactory):IFlexModuleFactory {
		super.moduleFactory = factory;

		if (__moduleFactoryInitialized) {
			return factory;
		}

		__moduleFactoryInitialized = true;

		// our style settings

		return factory;
	}

	//  initialize()
	/**
	 * @private
	 **/
	override public function initialize():Void {
		super.initialize();
	}

	//  scripts
	//  <Script>, line 45 - 248

	private var lineBreakChanged:Bool = false;
	private var paddingChanged:Bool = false;
	private var verticalAlignChanged:Bool = false;

	/* Define the skin elements that should not be colorized.
	   For text area, the skin itself is colorized but the individual parts are not as well
	   as the border since it uses the borderColor style. */
	private static var exclusions(default, never):Array<Dynamic> = cast ['background', 'scroller', 'promptDisplay', 'border'];

	/* exclusions before Flex 4.5 for backwards-compatibility purposes */
	private static var exclusions_4_0(default, never):Array<Dynamic> = cast ['background', 'scroller', 'promptDisplay'];

	/**
	 * @private
	 */
	override private function get_colorizeExclusions():Array<Dynamic> {
		// Since border is styleable via borderColor, no need to allow chromeColor to affect
		// the border.  This is wrapped in a compatibility flag since this change was added
		// in Flex 4.5
		if (FlexVersion.compatibilityVersion < FlexVersion.VERSION_4_5) {
			return exclusions_4_0;
		}

		return exclusions;
	}

	/* Define the content fill items that should be colored by the "contentBackgroundColor" style. */
	private static var contentFill(default, never):Array<Dynamic> = [];

	/**
	 *  @private
	 */
	override private function get_contentItems():Array<Dynamic> {
		return contentFill;
	}

	/**
	 *  @private
	 */
	override private function commitProperties():Void {
		super.commitProperties();

		if (lineBreakChanged) {
			updateStringStyle('lineBreak');
			lineBreakChanged = false;
		}
		if (paddingChanged) {
			updatePadding();
			paddingChanged = false;
		}
		if (verticalAlignChanged) {
			updateStringStyle('verticalAlign');
			verticalAlignChanged = false;
		}
	}

	/**
	 * @private
	 */
	override private function initializationComplete():Void {
		useChromeColor = true;
		super.initializationComplete();
	}

	/**
	 *  @private
	 */
	override private function updateDisplayList(unscaledWidth:Float, unscaledHeight:Float):Void {
		if (getStyle('borderVisible') == true) {
			border.visible = true;
			shadow.visible = true;
			//background.left = background.top = background.right = background.bottom = 1;
			textDisplay.left = textDisplay.top = textDisplay.right = textDisplay.bottom = 1;
			if (promptDisplay != null) {
				promptDisplay.setLayoutBoundsSize(unscaledWidth - 2, unscaledHeight - 2);
				promptDisplay.setLayoutBoundsPosition(1, 1);
			}
		} else {
			border.visible = false;
			shadow.visible = false;
			//background.left = background.top = background.right = background.bottom = 0;
			if (promptDisplay != null) {
				promptDisplay.setLayoutBoundsSize(unscaledWidth - 1, unscaledHeight - 1);
				promptDisplay.setLayoutBoundsPosition(1, 1);
			}
		}

		borderStroke.color = getStyle('borderColor');
		borderStroke.alpha = getStyle('borderAlpha');

		super.updateDisplayList(unscaledWidth, unscaledHeight);
	}

	/**
	 *  @private
	 */
	private function updatePadding():Void {
		if (textDisplay == null) {
			return;
		}

		// Push padding styles into the textDisplay
		var padding:Float;

		padding = getStyle('paddingLeft');
		if (textDisplay.getStyle('paddingLeft') != padding) {
			textDisplay.setStyle('paddingLeft', padding);
		}

		padding = getStyle('paddingTop');
		if (textDisplay.getStyle('paddingTop') != padding) {
			textDisplay.setStyle('paddingTop', padding);
		}

		padding = getStyle('paddingRight');
		if (textDisplay.getStyle('paddingRight') != padding) {
			textDisplay.setStyle('paddingRight', padding);
		}

		padding = getStyle('paddingBottom');
		if (textDisplay.getStyle('paddingBottom') != padding) {
			textDisplay.setStyle('paddingBottom', padding);
		}

		if (promptDisplay == null) {
			return;
		}

		padding = getStyle('paddingLeft');
		if (promptDisplay.getStyle('paddingLeft') != padding) {
			promptDisplay.setStyle('paddingLeft', padding);
		}

		padding = getStyle('paddingTop');
		if (promptDisplay.getStyle('paddingTop') != padding) {
			promptDisplay.setStyle('paddingTop', padding);
		}

		padding = getStyle('paddingRight');
		if (promptDisplay.getStyle('paddingRight') != padding) {
			promptDisplay.setStyle('paddingRight', padding);
		}

		padding = getStyle('paddingBottom');
		if (promptDisplay.getStyle('paddingBottom') != padding) {
			promptDisplay.setStyle('paddingBottom', padding);
		}
	}

	/**
	 *  @private
	 */
	private function updateStringStyle(styleName:String):Void {
		if (textDisplay == null) {
			return;
		}

		// Push style into the textDisplay
		var style:String;

		style = Std.string(getStyle(styleName));
		if (textDisplay.getStyle(styleName) != style) {
			textDisplay.setStyle(styleName, style);
		}

		if (promptDisplay == null) {
			return;
		}

		// Push style into the promptDisplay
		style = Std.string(getStyle(styleName));
		if (promptDisplay.getStyle(styleName) != style) {
			promptDisplay.setStyle(styleName, style);
		}
	}

	/**
	 *  @private
	 */
	override public function styleChanged(styleProp:String):Void {
		var allStyles:Bool = styleProp == null || styleProp == 'styleName';

		super.styleChanged(styleProp);

		if (allStyles || styleProp.indexOf('lineBreak') == 0) {
			lineBreakChanged = true;
			invalidateProperties();
		}
		if (allStyles || styleProp.indexOf('padding') == 0) {
			paddingChanged = true;
			invalidateProperties();
		}
		if (allStyles || styleProp.indexOf('verticalAlign') == 0) {
			verticalAlignChanged = true;
			invalidateProperties();
		}
	}

	//  <Script>, line 252 - 262

	/**
	 * @private
	 */
	private static var focusExclusions(default, never):Array<Dynamic> = cast ['textDisplay'];

	/**
	 *  @private
	 */
	override private function get_focusSkinExclusions():Array<Dynamic> {
		return focusExclusions;
	}

	//  end scripts

	//  supporting function definitions for properties, events, styles, effects
	private function _SparkTextAreaTransparentBG_Rect1_i():spark.primitives.Rect {
		var temp:spark.primitives.Rect = new spark.primitives.Rect();
		temp.left = 0;
		temp.right = 0;
		temp.top = 0;
		temp.bottom = 0;
		temp.stroke = _SparkTextAreaTransparentBG_SolidColorStroke1_i();
		temp.initialized(this, 'border');
		border = temp;
		mx.binding.BindingManager.executeBindings(this, 'border', border);
		return temp;
	}

	private function _SparkTextAreaTransparentBG_SolidColorStroke1_i():mx.graphics.SolidColorStroke {
		var temp:mx.graphics.SolidColorStroke = new mx.graphics.SolidColorStroke();
		temp.weight = 1;
		borderStroke = temp;
		mx.binding.BindingManager.executeBindings(this, 'borderStroke', borderStroke);
		return temp;
	}

	private function _SparkTextAreaTransparentBG_Rect2_i():spark.primitives.Rect {
		var temp:spark.primitives.Rect = new spark.primitives.Rect();
		temp.left = 1;
		temp.top = 1;
		temp.right = 1;
		temp.height = 1;
		temp.fill = _SparkTextAreaTransparentBG_SolidColor1_c();
		temp.initialized(this, 'shadow');
		shadow = temp;
		mx.binding.BindingManager.executeBindings(this, 'shadow', shadow);
		return temp;
	}

	private function _SparkTextAreaTransparentBG_SolidColor1_c():mx.graphics.SolidColor {
		var temp:mx.graphics.SolidColor = new mx.graphics.SolidColor();
		temp.color = 0;
		temp.alpha = 0.12;
		return temp;
	}

	private function _SparkTextAreaTransparentBG_Scroller1_i():spark.components.Scroller {
		var temp:spark.components.Scroller = new spark.components.Scroller();
		temp.left = 0;
		temp.top = 0;
		temp.right = 0;
		temp.bottom = 0;
		temp.minViewportInset = 1;
		temp.measuredSizeIncludesScrollBars = false;
		temp.hasFocusableChildren = false;
		temp.viewport = _SparkTextAreaTransparentBG_RichEditableText1_i();
		temp.id = 'scroller';
		if (!AS3.as(temp.document, Bool)) {
			temp.document = this;
		}
		scroller = temp;
		mx.binding.BindingManager.executeBindings(this, 'scroller', scroller);
		return temp;
	}

	private function _SparkTextAreaTransparentBG_RichEditableText1_i():spark.components.RichEditableText {
		var temp:spark.components.RichEditableText = new spark.components.RichEditableText();
		temp.heightInLines = 10;
		temp.widthInChars = 15;
		temp.styleName = 'uiTextSettingsValue';
		temp.id = 'textDisplay';
		if (!AS3.as(temp.document, Bool)) {
			temp.document = this;
		}
		textDisplay = temp;
		mx.binding.BindingManager.executeBindings(this, 'textDisplay', textDisplay);
		return temp;
	}

	private function _SparkTextAreaTransparentBG_Label1_i():spark.components.Label {
		var temp:spark.components.Label = new spark.components.Label();
		temp.mouseEnabled = false;
		temp.mouseChildren = false;
		temp.includeInLayout = false;
		temp.id = 'promptDisplay';
		if (!AS3.as(temp.document, Bool)) {
			temp.document = this;
		}
		promptDisplay = temp;
		mx.binding.BindingManager.executeBindings(this, 'promptDisplay', promptDisplay);
		return temp;
	}

}

//  end package def