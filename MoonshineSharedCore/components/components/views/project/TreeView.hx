/**
 *  Generated by mxmlc 4.0
 *
 *  Package:    components.views.project
 *  Class:      TreeView
 *  Source:     /Users/axgord/dev/Moonshine-IDE/ide/MoonshineSharedCore/src/components/views/project/TreeView.mxml
 *  Template:   flex2/compiler/mxml/gen/ClassDef.vm
 *  Time:       2019.04.22 23:25:47 MSK
 */

package components.views.project;

import actionScripts.events.PreviewPluginEvent;
import actionScripts.plugin.core.compiler.ProjectActionEvent;
import actionScripts.plugin.java.javaproject.vo.JavaProjectVO;
import mx.collections.ArrayCollection;
import mx.collections.Sort;
import mx.collections.SortField;
import mx.controls.Alert;
import mx.core.FlexGlobals;
import mx.events.CloseEvent;
import mx.events.CollectionEvent;
import mx.events.CollectionEventKind;
import mx.events.ListEvent;
import mx.events.TreeEvent;
import mx.managers.PopUpManager;
import actionScripts.events.AddFolderEvent;
import actionScripts.events.DeleteFileEvent;
import actionScripts.events.DuplicateEvent;
import actionScripts.events.FileCopyPasteEvent;
import actionScripts.events.GlobalEventDispatcher;
import actionScripts.events.HiddenFilesEvent;
import actionScripts.events.NewFileEvent;
import actionScripts.events.OpenFileEvent;
import actionScripts.events.ProjectEvent;
import actionScripts.events.RefreshVisualEditorSourcesEvent;
import actionScripts.events.RenameApplicationEvent;
import actionScripts.events.RenameEvent;
import actionScripts.events.RenameFileFolderEvent;
import actionScripts.events.RunANTScriptEvent;
import actionScripts.events.ShowSettingsEvent;
import actionScripts.events.TreeMenuItemEvent;
import actionScripts.factory.FileLocation;
import actionScripts.locator.IDEModel;
import actionScripts.plugin.actionscript.as3project.vo.AS3ProjectVO;
import actionScripts.plugin.templating.TemplatingHelper;
import actionScripts.ui.LayoutModifier;
import actionScripts.ui.renderers.FTETreeItemRenderer;
import actionScripts.ui.tabview.TabViewTab;
import actionScripts.utils.FileCoreUtil;
import actionScripts.utils.UtilsCore;
import actionScripts.valueObjects.ConstantsCoreVO;
import actionScripts.valueObjects.FileWrapper;
import actionScripts.valueObjects.ProjectVO;
import actionScripts.valueObjects.URLDescriptorVO;
import components.popup.NewFolderPopup;

import flash.errors.Error;
import haxe.Constraints.Function;
import actionScripts.ui.IPanelWindow;
import actionScripts.ui.project.ProjectViewHeader;
import actionScripts.utils.CustomTree;
import flash.accessibility.*;
import flash.debugger.*;
import flash.display.*;
import flash.errors.*;
import flash.events.*;
import flash.events.Event;
import flash.external.*;
import flash.filters.*;
import flash.geom.*;
import flash.media.*;
import flash.net.*;
import flash.printing.*;
import flash.profiler.*;
import flash.system.*;
import flash.text.*;
import flash.ui.*;
import flash.utils.*;
import flash.xml.*;
import mx.binding.*;
import mx.binding.IBindingClient;
import mx.containers.VBox;
import mx.core.ClassFactory;
import mx.core.DeferredInstanceFromClass;
import mx.core.DeferredInstanceFromFunction;
import mx.core.IDeferredInstance;
import mx.core.IFactory;
import mx.core.IFlexModuleFactory;
import mx.core.IPropertyChangeNotifier;
import mx.core.UIComponentDescriptor;
import mx.core.Mx_internal;
import mx.events.FlexEvent;

import mx.styles.*;

//  begin class def
class TreeView extends mx.containers.VBox implements actionScripts.ui.IPanelWindow implements mx.binding.IBindingClient {

	//  instance variables
	@:meta(Bindable())
	/**
	 * @private
	 **/
	public var header:actionScripts.ui.project.ProjectViewHeader;

	@:meta(Bindable())
	/**
	 * @private
	 **/
	public var tree:actionScripts.utils.CustomTree;

	//  type-import dummies

	//  Container document descriptor
	private var _documentDescriptor_:mx.core.UIComponentDescriptor;

	//  constructor (Flex display object)
	/**
	 * @private
	 **/
	public function new() {
		this._documentDescriptor_ =
				new mx.core.UIComponentDescriptor({
					'type': mx.containers.VBox,
					'propertiesFactory': function():Dynamic {
						return {
							'childDescriptors': [
							new mx.core.UIComponentDescriptor({
								'type': actionScripts.ui.project.ProjectViewHeader,
								'id': 'header',
								'events': {
									'scrollFromSource': '__header_scrollFromSource',
									'creationComplete': '__header_creationComplete'
								},
								'propertiesFactory': function():Dynamic {
									return {
										'label': 'Projects',
										'showScrollFromSourceIcon': true,
										'percentWidth': 100.0
									};
								}
							}),
							new mx.core.UIComponentDescriptor({
								'type': actionScripts.utils.CustomTree,
								'id': 'tree',
								'events': {
									'itemOpen': '__tree_itemOpen',
									'itemClose': '__tree_itemClose',
									'itemDoubleClick': '__tree_itemDoubleClick',
									'itemClick': '__tree_itemClick',
									'creationComplete': '__tree_creationComplete'
								},
								'stylesFactory': function():Void {
									this.color = 15658734;
									this.contentBackgroundColor = 0;
									this.rollOverColor = 3750201;
									this.selectionColor = 12674488;
									this.alternatingItemColors = [4473924, 5065804];
									this.verticalScrollBarStyleName = 'black';
									this.borderVisible = false;
									this.useRollOver = true;
								},
								'propertiesFactory': function():Dynamic {
									return {
										'percentWidth': 100.0,
										'percentHeight': 100.0,
										'propertyNameKey': 'name',
										'propertyNameKeyValue': 'nativePath',
										'showDataTips': true,
										'dataTipFunction': this.getTreeTooltip,
										'keyNav': true,
										'rowHeight': 18,
										'allowMultipleSelection': true,
										'doubleClickEnabled': true,
										'labelField': 'name'
									};
								}
							})
				]
						};
					}
				});
		super();

		// mx_internal::_document = this;

		var bindings:Array<Dynamic> = _TreeView_bindingsSetup();
		var watchers:Array<Dynamic> = [];

		var target:Dynamic = this;

		if (_watcherSetupUtil == null) {
			var watcherSetupUtilClass:Dynamic = Type.resolveClass('_components_views_project_TreeViewWatcherSetupUtil');
			Reflect.field(watcherSetupUtilClass, 'init')(null);
		}

		_watcherSetupUtil.setup(this,
				function(propertyName:String):Dynamic {
					return Reflect.field(target, propertyName);
				},
				function(propertyName:String):Dynamic {
					return Reflect.getProperty(TreeView, propertyName);
				},
				bindings,
				watchers
		);

		// mx_internal::_bindings =  //  mx_internal::_bindings.concat(bindings);
		// mx_internal::_watchers =  //  mx_internal::_watchers.concat(watchers);

		// layer initializers

		// properties
		this.percentWidth = 100.0;
		this.percentHeight = 100.0;

		// events
		this.addEventListener('preinitialize', ___TreeView_VBox1_preinitialize);
		this.addEventListener('remove', ___TreeView_VBox1_remove);

		for (i in 0...bindings.length) {
			AS3.as(bindings[i], Binding).execute();
		}

	}

	/**
	 * @private
	 **/
	private var __moduleFactoryInitialized:Bool = false;

	/**
	 * @private
	 * Override the module factory so we can defer setting style declarations
	 * until a module factory is set. Without the correct module factory set
	 * the style declaration will end up in the wrong style manager.
	 **/
	override private function set_moduleFactory(factory:IFlexModuleFactory):IFlexModuleFactory {
		super.moduleFactory = factory;

		if (__moduleFactoryInitialized) {
			return factory;
		}

		__moduleFactoryInitialized = true;

		// our style settings
		//  initialize component styles
		if (!AS3.as(this.styleDeclaration, Bool)) {
			this.styleDeclaration = new CSSStyleDeclaration(null, styleManager);
		}

		this.styleDeclaration.defaultFactory = function():Void {
					this.backgroundColor = 4473924;
					this.verticalGap = 0;
				};
		return factory;
	}

	//  initialize()
	/**
	 * @private
	 **/
	override public function initialize():Void {
		// mx_internal::setDocumentDescriptor(_documentDescriptor_);

		super.initialize();
	}

	//  scripts
	//  <Script>, line 30 - 1099

	private var newFolderWindow:NewFolderPopup;

	// Renaming
	private var currentEditedItem:FTETreeItemRenderer;
	private var model:IDEModel = IDEModel.getInstance();
	private var dispatcher:GlobalEventDispatcher = GlobalEventDispatcher.getInstance();

	// Creating new file
	private var creatingItemIn:FileWrapper;
	private var templateToCreate:FileLocation;

	//For sorting
	private var dataSortField:SortField = new SortField();
	private var DataSort:Sort = new Sort();
	private var deleteFileWrapper:FileWrapper;
	private var fileCollection:Array<Dynamic>;

	private var _projects:ArrayCollection;

	@:meta(Bindable())
	public var projectFolders:ArrayCollection;

	@:meta(Bindable())
	public var projects(get, set):ArrayCollection;
	private function get_projects():ArrayCollection {
		return _projects;
	}

	private function set_projects(value:ArrayCollection):ArrayCollection {
		if (projects != null) {
			projects.removeEventListener(CollectionEvent.COLLECTION_CHANGE, handleProjectsChange);
		}

		_projects = value;
		_projects.addEventListener(CollectionEvent.COLLECTION_CHANGE, handleProjectsChange);

		// Scrape up all .projectFolders in here
		var pdirs:Array<Dynamic> = [];
		for (i in 0...value.length) {
			var project:ProjectVO = Reflect.getProperty(value, Std.string(i));
			pdirs.push(project.projectFolder);
		}

		projectFolders = new ArrayCollection(pdirs);

		dataSortField.name = 'name';
		dataSortField.numeric = false;
		DataSort.fields = [dataSortField];
		projectFolders.sort = DataSort;
		projectFolders.refresh();
		model.selectedprojectFolders = projectFolders;
		return value;
	}

	private function refreshFileFolder(fileWrapper:FileWrapper, project:ProjectVO = null):Void {
		if (project == null) {
			project = UtilsCore.getProjectFromProjectFolder(fileWrapper);
		}
		var asProject:AS3ProjectVO = AS3.as(project, AS3ProjectVO);

		if (!AS3.as(ConstantsCoreVO.IS_AIR, Bool)) {
			refreshProjectFromServer(fileWrapper, project);
			return;
		}

		if (asProject != null && asProject.isVisualEditorProject) {
			dispatcher.dispatchEvent(
					new RefreshVisualEditorSourcesEvent(RefreshVisualEditorSourcesEvent.REFRESH_VISUALEDITOR_SRC,
					fileWrapper, asProject)
			);
		} else if (fileWrapper != null) {
			refreshByWrapperItem(fileWrapper);
		}
	}

	private function refreshByWrapperItem(fileWrapper:FileWrapper):Void {
		if (!AS3.as(fileWrapper.file.fileBridge.isDirectory, Bool)) {
			refresh(fileWrapper.file.fileBridge.parent, fileWrapper.isDeleting);
		} else {
			refreshItem(fileWrapper);
		}

		if (fileWrapper.sourceController != null) {
			fileWrapper.sourceController.refresh(fileWrapper.file);
		}

		if (fileWrapper.isRoot) {
			var project:ProjectVO = AS3.as(UtilsCore.getProjectFromProjectFolder(fileWrapper), ProjectVO);
			var sourceWrapper:FileWrapper = null;
			if (Std.is(project, AS3ProjectVO)) {
				var as3Project:AS3ProjectVO = AS3ProjectVO(project);
				sourceWrapper = UtilsCore.findFileWrapperAgainstFileLocation(project.projectFolder, as3Project.sourceFolder);
			} else if (Std.is(project, JavaProjectVO)) {
				var javaProject:JavaProjectVO = JavaProjectVO(project);
				sourceWrapper = UtilsCore.findFileWrapperAgainstFileLocation(project.projectFolder, javaProject.sourceFolder);
			}
			if (sourceWrapper != null && sourceWrapper != project.projectFolder) {
				sourceWrapper.isSourceFolder = true;
			}
		}
	}

	public function refresh(dir:FileLocation, markAsDeletion:Bool = false):Void {
		for (fw in projectFolders) {
			if (AS3.as(ConstantsCoreVO.IS_AIR, Bool)) {
				if ((dir.fileBridge.nativePath + dir.fileBridge.separator).indexOf(Reflect.field(fw, 'nativePath') + dir.fileBridge.separator) != -1) {
					var tmpFW:FileWrapper = UtilsCore.findFileWrapperAgainstFileLocation(fw, dir);
					if (tmpFW != null) {
						if (AS3.as(tree.selectedItem, Bool)) {
							var lastSelectedItem:FileWrapper = AS3.as(tree.selectedItem, FileWrapper);
							if (tmpFW.nativePath == lastSelectedItem.nativePath || lastSelectedItem.nativePath.indexOf(tmpFW.nativePath + tmpFW.file.fileBridge.separator) != -1) {
								tree.selectedItem.isDeleting = markAsDeletion;
							}
						}
						refreshItem(tmpFW);
					}
					return;
				}
			} else {
				refreshItem(UtilsCore.findFileWrapperAgainstFileLocation(fw, dir));
			}
		}
	}

	private function onCreationCompletes():Void {
		dispatcher.addEventListener(ProjectEvent.TREE_DATA_UPDATES, onProjectTreeUpdates, false, 0, true);
		dispatcher.addEventListener(ProjectEvent.PROJECT_FILES_UPDATES, onProjectFilesUpdates, false, 0, true);
		dispatcher.addEventListener(TreeMenuItemEvent.NEW_FILE_CREATED, onFileNewFolderCreationRequested, false, 0, true);
		dispatcher.addEventListener(TreeMenuItemEvent.NEW_FILES_FOLDERS_COPIED, onNewFilesFoldersCopied, false, 0, true);
		dispatcher.addEventListener(RenameApplicationEvent.RENAME_APPLICATION_FOLDER, onProjectRenameRequest, false, 0, true);
	}

	private function onRemoval():Void {
		dispatcher.removeEventListener(ProjectEvent.TREE_DATA_UPDATES, onProjectTreeUpdates);
		dispatcher.removeEventListener(ProjectEvent.PROJECT_FILES_UPDATES, onProjectFilesUpdates);
		dispatcher.removeEventListener(TreeMenuItemEvent.NEW_FILE_CREATED, onFileNewFolderCreationRequested);
		dispatcher.removeEventListener(TreeMenuItemEvent.NEW_FILES_FOLDERS_COPIED, onNewFilesFoldersCopied);
		dispatcher.removeEventListener(RenameApplicationEvent.RENAME_APPLICATION_FOLDER, onProjectRenameRequest);
	}

	private function refreshProjectFromServer(fw:FileWrapper, project:ProjectVO):Void {
		// determine to which project fileWrapper is belongs to
		var projectIndex:Int = -1;
		if (projectFolders.length > 1) {
			for (i in 0...projectFolders.length) {
				if (Reflect.getProperty(projectFolders, Std.string(i)) == fw) {
					projectIndex = i;
					break;
				}
			}
		} else {
			projectIndex = 0;
		}

		Reflect.getProperty(projectFolders, Std.string(projectIndex)).isWorking = true;
		var projectPath:String = project.projectFolder.nativePath;
		var tmpProjectVO:ProjectVO = new ProjectVO(new FileLocation(URLDescriptorVO.PROJECT_DIR + projectPath), Std.string(Reflect.getProperty(projectFolders, Std.string(projectIndex)).name), false);
		tmpProjectVO.projectRemotePath = project.projectFolder.nativePath;
		tmpProjectVO.addEventListener(ProjectVO.PROJECTS_DATA_UPDATED, onTmpProjectUpdated, false, 0, true);
		tmpProjectVO.addEventListener(ProjectVO.PROJECTS_DATA_FAULT, onTmpProjectUpdateFault, false, 0, true);

		var onTmpProjectUpdated:Event->Void = function(event:Event):Void {
			onTmpProjectUpdateFault(null);

			Reflect.setProperty(projects, Std.string(projectIndex), tmpProjectVO);
			Reflect.setProperty(projectFolders, Std.string(projectIndex), tmpProjectVO.projectFolder);
			IDEModel.getInstance().selectedprojectFolders = projectFolders;
			refreshItem(Reflect.getProperty(projectFolders, Std.string(projectIndex)));
		}

		var onTmpProjectUpdateFault:Event->Void = function(event:Event):Void {
			tmpProjectVO.removeEventListener(ProjectVO.PROJECTS_DATA_UPDATED, onTmpProjectUpdated);
			tmpProjectVO.removeEventListener(ProjectVO.PROJECTS_DATA_FAULT, onTmpProjectUpdateFault);
			Reflect.getProperty(projectFolders, Std.string(projectIndex)).isWorking = false;
		}
	}

	private function refreshItem(fw:FileWrapper):Void {
		var lastScrollPosition:Float = tree.verticalScrollPosition;
		var lastSelectedItem:Dynamic = tree.selectedItem;
		var lastSelectedIndex:Int = AS3.int(tree.selectedIndex);
		var openItems:Dynamic = tree.openItems;
		fw.updateChildren();
		tree.openItems = openItems;
		tree.invalidateList();

		tree.callLater(function():Void {
					tree.verticalScrollPosition = lastScrollPosition;
				});

		var timeoutValue:Int = as3hx.Compat.setTimeout(function():Void {
					if (AS3.as(lastSelectedItem, Bool) && AS3.as(Reflect.field(lastSelectedItem, 'isDeleting'), Bool)) {
						if (AS3.as(tree.isItemVisible(lastSelectedItem), Bool)) {
							tree.selectedItem = lastSelectedItem;
						} else {
							setSelectedItem(AS3.as(lastSelectedItem, FileWrapper));
						}
					} else {
						tree.selectedItem = lastSelectedItem;
					}

					// if still there has no selection to the tree
					if (!AS3.as(tree.selectedItem, Bool) && lastSelectedIndex != -1) {
						tree.selectedIndex = lastSelectedIndex;
					}
					as3hx.Compat.clearTimeout(timeoutValue);
				}, 100);
	}

	private function setSelectedItem(fw:FileWrapper):Void {
		var filew:FileWrapper;
		if (projectFolders.length > 1) {
			for (i in 0...projectFolders.length) {
				if (fw.nativePath.indexOf((AS3.as(Reflect.getProperty(projectFolders, Std.string(i)), FileWrapper)).nativePath) >= 0) {
					filew = AS3.as(Reflect.getProperty(projectFolders, Std.string(i)), FileWrapper);
					break;
				}
			}
		} else {
			filew = AS3.as(Reflect.getProperty(projectFolders, Std.string(0)), FileWrapper);
		}

		tree.selectedItem = filew;
	}

	public function handleProjectsChange(event:CollectionEvent):Void {
		var project:ProjectVO = null;
		var timeoutValue:Int;
		switch (event.kind) {
			case CollectionEventKind.REMOVE:
				project = AS3.as(Reflect.getProperty(event.items, Std.string(0)), ProjectVO);
				// after a project renaming, and updating its internal fields
				// direct search (i.e. getItemIndex) of fileWrapper object in the collection
				// returns -1 even the fileWrapper object and object inside the collection has same
				// instance id. Thus a different approach it needs to parse by its uid value
				var lastSelectedItem:Dynamic = tree.selectedItem;
				var tmpFWIndex:Int = UtilsCore.findFileWrapperIndexByID(project.projectFolder, projectFolders);
				projectFolders.removeItemAt(tmpFWIndex);
				timeoutValue = as3hx.Compat.setTimeout(function():Void {
									if (AS3.as(tree.isItemVisible(lastSelectedItem), Bool)) {
										tree.selectedItem = lastSelectedItem;
									} else if (projectFolders.length != 0) {
										tree.selectedItem = ((--tmpFWIndex != -1)) ? Reflect.getProperty(projectFolders, Std.string(tmpFWIndex)) : Reflect.getProperty(projectFolders, Std.string(++tmpFWIndex));
									}
									as3hx.Compat.clearTimeout(timeoutValue);
									refreshActiveProject(AS3.as(tree.selectedItem, FileWrapper));
								}, 100);
			case CollectionEventKind.ADD:
				project = AS3.as(projects.getItemAt(event.location), ProjectVO);

				var sourceWrapper:FileWrapper = null;
				if (Std.is(project, AS3ProjectVO)) {
					var as3Project:AS3ProjectVO = AS3ProjectVO(project);
					sourceWrapper = UtilsCore.findFileWrapperAgainstFileLocation(project.projectFolder, as3Project.sourceFolder);
				} else if (Std.is(project, JavaProjectVO)) {
					var javaProject:JavaProjectVO = JavaProjectVO(project);
					sourceWrapper = UtilsCore.findFileWrapperAgainstFileLocation(project.projectFolder, javaProject.sourceFolder);
				}
				if (sourceWrapper != null && sourceWrapper != project.projectFolder) {
					sourceWrapper.isSourceFolder = true;
				}

				projectFolders.addItemAt(project.projectFolder, 0);
				if ((Std.is(project, AS3ProjectVO)) && (AS3.as(project, AS3ProjectVO)).isVisualEditorProject) {
					refreshFileFolder(project.projectFolder, project);
				}
				timeoutValue = as3hx.Compat.setTimeout(function():Void {
									tree.selectedItem = project.projectFolder;
									as3hx.Compat.clearTimeout(timeoutValue);
									refreshActiveProject(AS3.as(tree.selectedItem, FileWrapper));
									if (ConstantsCoreVO.STARTUP_PROJECT_OPEN_QUEUE_LEFT > 0) {
										ConstantsCoreVO.STARTUP_PROJECT_OPEN_QUEUE_LEFT--;
									}
								}, 1000);
		}

		model.selectedprojectFolders = projectFolders;
	}

	private function onProjectTreeUpdates(event:ProjectEvent):Void {
		projectFolders.addItemAt(event.project.projectFolder, 0);

		// I don't know why the heck projectFolders having null value from where
		// is a fix to the probelm for now
		if (!AS3.as(ConstantsCoreVO.IS_AIR, Bool)) {
			var i:Int = 0;
			while (i < projectFolders.length) {
				if (Reflect.getProperty(projectFolders, Std.string(i)) == null) {
					projectFolders.removeItemAt(i);
					i--;
				}
				i++;
			}
		}

		model.selectedprojectFolders = projectFolders;
	}

	private function onProjectFilesUpdates(event:ProjectEvent):Void {
		refreshItem(AS3.as(event.anObject, FileWrapper));
	}

	private function initHeader():Void {
		header.addEventListener(TabViewTab.EVENT_TAB_CLOSE, handleClose);
	}

	private function initTree():Void {
		tree.addEventListener(TreeMenuItemEvent.RIGHT_CLICK_ITEM_SELECTED, handleNativeMenuItemClick);
	}

	private function handleClose(event:Event):Void {
		if (stage != null) {
			LayoutModifier.removeFromSidebar(this);
		}
	}

	private function handleNativeMenuItemClick(event:TreeMenuItemEvent):Void {
		function onFileDeleteConfirm(event2:CloseEvent):Void {
			if (event2 == null || event2.detail == Alert.YES) {
				var projectAssociatedWithFile:ProjectVO = UtilsCore.getProjectFromProjectFolder(AS3.as(Reflect.getProperty(tree.selectedItems, Std.string(0)), FileWrapper));
				dispatcher.dispatchEvent(new DeleteFileEvent(fileWrapper.file, (isMultiSelection) ? tree.selectedItems : cast [fileWrapper], onFileDeletedOnServer, event.showAlert, projectAssociatedWithFile));
			}
		};
		function renameFileFolder(rendererObject:FTETreeItemRenderer):Void {
			dispatcher.dispatchEvent(new RenameEvent(RenameEvent.EVENT_OPEN_RENAME_FILE_VIEW, rendererObject.data));
		};
		function isMultiSelectionIsValid():Bool {
			var hasProjectRoot:Bool;
			var hasProjectFiles:Bool;
			for (fw in as3hx.Compat.each(tree.selectedItems)) {
				if (AS3.as(Reflect.field(fw, 'isRoot'), Bool)) {
					hasProjectRoot = true;
				} else {
					hasProjectFiles = true;
				}

				// terminate if any file do not exists
				if (!AS3.as(Reflect.field(Reflect.field(Reflect.field(fw, 'file'), 'fileBridge'), 'exists'), Bool)) {
					Alert.show('One or more files to the selection does not exists.', 'Error');
					return false;
				}
			}

			// terminates if project and project's files selected at same time
			if (hasProjectFiles && hasProjectRoot) {
				Alert.show('Project and files of projects are not allowed to bulk delete.', 'Error');
				return false;
			}

			// terminate if multiple projects are trying to delete
			// (based on the current popup confirmation design with files to be deleted -
			// we should show only confirmation to reduce complexity
			if (hasProjectRoot && tree.selectedItems.length > 1) {
				Alert.show('Multiple projects are are not allowed to bulk delete.', 'Error');
				return false;
			}

			return true;
		};
		function openFileFolder(fws:Array<Dynamic>):Void {
			var tmpFLs:Array<Dynamic> = [];
			var tmpFWs:Array<Dynamic> = [];
			for (fw_ in fws) {
				var fw:FileWrapper = cast fw_;
				if (AS3.as(Reflect.field(Reflect.field(Reflect.field(fw, 'file'), 'fileBridge'), 'isDirectory'), Bool) && AS3.as(tree.dataDescriptor.isBranch(fw), Bool)) {
					tree.expandItem(fw, true, true);
				} else {
					tmpFLs.push(Reflect.field(fw, 'file'));
					tmpFWs.push(fw);
				}
			}

			if (tmpFLs.length > 0) {
				dispatcher.dispatchEvent(new OpenFileEvent(OpenFileEvent.OPEN_FILE, tmpFLs, -1, tmpFWs));
			}
		};
		// Might be some sub-menu provider we're dealing with
		if (!(Std.is(event.data, FileWrapper))) {
			return;
		}

		var project:ProjectVO;
		var fileWrapper:FileWrapper = FileWrapper(event.data);
		var isMultiSelection:Bool;
		var fw:FileWrapper;

		if ((tree.selectedItems.length > 1)
			&& (tree.selectedItems.indexOf(fileWrapper) != -1)) {
			isMultiSelection = true;
		} /*
		* @local
		* opens a folder or open a file
		*/  /*
		* @local
		* Checks if multi-selection is valid to proceed
		* against context-menu options
		*/  /*
		 * @local
		 * Rename file/folder
		 */  /*
		* @local
		* file delete
		*/

		switch (event.menuLabel) {
			case FTETreeItemRenderer.SETTINGS, FTETreeItemRenderer.PROJECT_SETUP:
				project = UtilsCore.getProjectFromProjectFolder(fileWrapper);
				dispatcher.dispatchEvent(
						new ShowSettingsEvent(project)
			);
			case FTETreeItemRenderer.OPEN, FTETreeItemRenderer.OPEN_FILE_FOLDER:
				if (isMultiSelection) {
					openFileFolder(tree.selectedItems);
				} else {
					openFileFolder(cast [fileWrapper]);
				}
			case FTETreeItemRenderer.CLOSE:
				onFileDeletedOnServer(cast [fileWrapper], event.menuLabel);
				refreshActiveProject(fileWrapper);
			case FTETreeItemRenderer.DELETE, FTETreeItemRenderer.DELETE_PROJECT, FTETreeItemRenderer.DELETE_FILE_FOLDER:
				if (isMultiSelection && isMultiSelectionIsValid()) {
					Alert.show('Are you sure you want to delete all selected files and folders from the file system?', 'Confirm', Alert.YES | Alert.CANCEL, null, onFileDeleteConfirm);
					return;
				} else if (!isMultiSelection) {
					if (fileWrapper.isWorking) {
						return;
					}
					if (!fileWrapper.isRoot && AS3.as(fileWrapper.file.fileBridge.exists, Bool)) {
						Alert.show('Are you sure you want to delete \'' + fileWrapper.file.fileBridge.name + '\' from the file system?', 'Confirm', Alert.YES | Alert.CANCEL, null, onFileDeleteConfirm);
					} else {
						onFileDeleteConfirm(null);
					}
				}
			case FTETreeItemRenderer.RENAME:
				renameFileFolder(AS3.as(event.renderer, FTETreeItemRenderer));
			case FTETreeItemRenderer.DUPLICATE_FILE:
				dispatcher.dispatchEvent(new DuplicateEvent(DuplicateEvent.EVENT_OPEN_DUPLICATE_FILE_VIEW, fileWrapper));
			case FTETreeItemRenderer.COPY_FILE:
				dispatcher.dispatchEvent(new FileCopyPasteEvent(FileCopyPasteEvent.EVENT_COPY_FILE, (isMultiSelection) ? tree.selectedItems : cast [fileWrapper]));
			case FTETreeItemRenderer.PASTE_FILE:
				dispatcher.dispatchEvent(new FileCopyPasteEvent(FileCopyPasteEvent.EVENT_PASTE_FILES, (AS3.as(fileWrapper.file.fileBridge.isDirectory, Bool)) ? cast [fileWrapper] : [FileWrapper(tree.getParentItem(fileWrapper))]));
			case FTETreeItemRenderer.SET_AS_DEFAULT_APPLICATION:
				if (Std.is(model.activeProject, AS3ProjectVO)) {
					TemplatingHelper.setFileAsDefaultApplication(fileWrapper, FileWrapper(tree.getParentItem(fileWrapper)));
				} else if (Std.is(model.activeProject, JavaProjectVO)) {
					dispatcher.dispatchEvent(new ProjectActionEvent(ProjectActionEvent.SET_DEFAULT_APPLICATION, fileWrapper.file));
				}
			case FTETreeItemRenderer.REFRESH:
				refreshFileFolder(fileWrapper);
			case FTETreeItemRenderer.NEW:
				// Right-clicking a directory creates the file in the dir,
				// otherwise create in same dir as clicked file
				creatingItemIn = ((AS3.as(fileWrapper.file.fileBridge.isDirectory, Bool) || !AS3.as(fileWrapper.file.fileBridge.exists, Bool))) ?
						fileWrapper : FileWrapper(tree.getParentItem(fileWrapper));
				if (!AS3.as(creatingItemIn.file.fileBridge.checkFileExistenceAndReport(), Bool)) {
					return;
				}

				// for new file type creation
				if (event.extra != FTETreeItemRenderer.NEW_FOLDER) {
					var newFileEvent:NewFileEvent = new NewFileEvent(Std.string(event.extra), Std.string(creatingItemIn.file.fileBridge.nativePath), null, creatingItemIn);
					newFileEvent.ofProject = UtilsCore.getProjectFromProjectFolder(fileWrapper);

					dispatcher.dispatchEvent(newFileEvent);
				} else if (newFolderWindow == null) {
					newFolderWindow = AS3.as(PopUpManager.createPopUp(AS3.as(FlexGlobals.topLevelApplication, DisplayObject), NewFolderPopup, true), NewFolderPopup);
					newFolderWindow.addEventListener(CloseEvent.CLOSE, handleNewFolderPopupClose);
					newFolderWindow.addEventListener(NewFileEvent.EVENT_NEW_FOLDER, onFileNewFolderCreationRequested);
					newFolderWindow.wrapperOfFolderLocation = creatingItemIn;
					newFolderWindow.wrapperBelongToProject = UtilsCore.getProjectFromProjectFolder(fileWrapper);

					PopUpManager.centerPopUp(newFolderWindow);
				}
			case FTETreeItemRenderer.RUN_ANT_SCRIPT:
				model.antScriptFile = new FileLocation(Std.string(fileWrapper.file.fileBridge.nativePath));
				dispatcher.dispatchEvent(new RunANTScriptEvent(RunANTScriptEvent.ANT_BUILD));
			case FTETreeItemRenderer.COPY_PATH:
				FileCoreUtil.copyPathToClipboard(fileWrapper.file);
			case FTETreeItemRenderer.SHOW_IN_EXPLORER, FTETreeItemRenderer.SHOW_IN_FINDER:
				FileCoreUtil.showInExplorer(fileWrapper.file);
			case FTETreeItemRenderer.MARK_AS_VISIBLE:
				dispatcher.dispatchEvent(new HiddenFilesEvent(HiddenFilesEvent.MARK_FILES_AS_VISIBLE, fileWrapper));
			case FTETreeItemRenderer.MARK_AS_HIDDEN:
				dispatcher.dispatchEvent(new HiddenFilesEvent(HiddenFilesEvent.MARK_FILES_AS_HIDDEN, fileWrapper));
			case FTETreeItemRenderer.PREVIEW:
				dispatcher.dispatchEvent(new PreviewPluginEvent(PreviewPluginEvent.START_VISUALEDITOR_PREVIEW, fileWrapper));
		}
	}

	private function handleNewFolderPopupClose(event:CloseEvent):Void {
		newFolderWindow.removeEventListener(CloseEvent.CLOSE, handleNewFolderPopupClose);
		newFolderWindow.removeEventListener(NewFileEvent.EVENT_NEW_FOLDER, onFileNewFolderCreationRequested);
		newFolderWindow = null;
	}

	private function onFileNewFolderCreationRequested(event:Event):Void {
		// @note
		// NewFileEvent calls in case of folder creation, and
		// it's TreeMenuItemEvent in case of file creation

		var fileName:String;
		var newFileLocation:FileLocation;
		var insideLocation:FileWrapper = ((Std.is(event, NewFileEvent))) ? NewFileEvent(event).insideLocation : TreeMenuItemEvent(event).data;
		if (Std.is(event, NewFileEvent)) {
			fileName = Std.string(NewFileEvent(event).fileName);

			newFileLocation = insideLocation.file.fileBridge.resolvePath(fileName);
			if (!AS3.as(newFileLocation.fileBridge.exists, Bool)) {
				newFileLocation.fileBridge.createDirectory();
			}
		} else if (AS3.as((AS3.as(event, TreeMenuItemEvent)).extra, Bool) && (Std.is((AS3.as(event, TreeMenuItemEvent)).extra, FileLocation))) {
			newFileLocation = AS3.as((AS3.as(event, TreeMenuItemEvent)).extra, FileLocation);
		} else {
			var tmpArray:Array<Dynamic> = TreeMenuItemEvent(event).menuLabel.split(model.fileCore.separator);
			fileName = Std.string(tmpArray[tmpArray.length - 1]);

			newFileLocation = new FileLocation(Std.string(TreeMenuItemEvent(event).menuLabel));
		}

		var newFile:FileWrapper = new FileWrapper(newFileLocation, false, insideLocation.projectReference);
		newFile.defaultName = fileName;
		if ((Type.getInstanceFields(Type.getClass(NewFileEvent)).indexOf(event) != -1)) {
			newFile.children = [];
		}
		insideLocation.children.push(newFile);

		// Make sure item is open before adding
		tree.callLater(tree.expandItem, [insideLocation, true]);

		// refresh the folder section and select
		var timeoutValue:Int = as3hx.Compat.setTimeout(function():Void {
					insideLocation.sortChildren();

					// after a refresh new fileWrapper being created,
					// so we need new instance of the wrapper so we can
					// select and scroll-to-index
					var tmpFileW:FileWrapper = UtilsCore.findFileWrapperAgainstProject(newFile, null, insideLocation);
					tree.selectedItem = tmpFileW;

					var indexToItemRenderer:Int = AS3.int(tree.getItemIndex(tmpFileW));
					tree.callLater(tree.scrollToIndex, [indexToItemRenderer]);
					as3hx.Compat.clearTimeout(timeoutValue);
				}, 300);
	}

	private function onNewFilesFoldersCopied(event:TreeMenuItemEvent):Void {
		var insideLocation:FileWrapper = TreeMenuItemEvent(event).data;

		// refresh the folder section and select
		tree.selectedItem = insideLocation;
		refreshByWrapperItem(insideLocation);
		tree.callLater(tree.expandItem, [insideLocation, true]);
	}

	private function onProjectRenameRequest(event:RenameApplicationEvent):Void {
		for (as3Project in model.projects) {
			if (Reflect.field(Reflect.field(Reflect.field(as3Project, 'folderLocation'), 'fileBridge'), 'nativePath') == event.from.fileBridge.nativePath) {
				Reflect.setField(Reflect.field(as3Project, 'projectFolder'), 'file', Reflect.setField(as3Project, 'folderLocation', Reflect.setField(Reflect.field(as3Project, 'classpaths'), Std.string(0), event.to)));
				Reflect.setField(Reflect.field(Reflect.field(as3Project, 'projectFolder'), 'projectReference'), 'name', event.to.fileBridge.name);
				Reflect.setField(Reflect.field(Reflect.field(as3Project, 'projectFolder'), 'projectReference'), 'path', event.to.fileBridge.nativePath);

				refreshByWrapperItem(Reflect.field(as3Project, 'projectFolder'));

				var timeoutValue:Int = as3hx.Compat.setTimeout(function():Void {
							tree.selectedItem = Reflect.field(as3Project, 'projectFolder');

							var indexToItemRenderer:Int = AS3.int(tree.getItemIndex(Reflect.field(as3Project, 'projectFolder')));
							tree.callLater(tree.scrollToIndex, [indexToItemRenderer]);
							as3hx.Compat.clearTimeout(timeoutValue);
						}, 300);
				break;
			}
		}
	}

	public function getProjectBySelection(orByProjectPath:String = null):ProjectVO {
		if (!AS3.as(tree.selectedItem, Bool) && orByProjectPath == null) {
			return null;
		}

		for (i in ...projects.length) {
			if (orByProjectPath == null) {
				if (FileWrapper(tree.selectedItem).projectReference.path == Reflect.getProperty(projects, Std.string(i)).folderPath) {
					return Reflect.getProperty(projects, Std.string(i));
				}
			} else if (orByProjectPath == Std.string(Reflect.getProperty(projects, Std.string(i)).folderPath)) {
				return Reflect.getProperty(projects, Std.string(i));
			}
		}

		return null;
	}

	private function onFileDeletedOnServer(value:Array<Dynamic>, removalType:String = null):Void {
		function updateTreeView():Void {
			model.selectedprojectFolders = projectFolders;
		};
		if (value == null) {
			return;
		}

		var parentCollection:Array<Dynamic>;
		var tmpProject:ProjectVO;
		var lastSelectedItem:Dynamic = tree.selectedItem;
		var lastProcessedProjectPath:String; /*
		*@local
		*/
		// if the file/folder is a project root
		if (AS3.as(Reflect.field(value[0], 'isRoot'), Bool)) {
			tmpProject = UtilsCore.getProjectFromProjectFolder(value[0]);
			UtilsCore.closeAllRelativeEditors((tmpProject != null) ? tmpProject : value[0], (removalType == Std.string(FTETreeItemRenderer.CLOSE)) ? false : true, function():Void {
						for (project in projects) {
							if (Reflect.field(Reflect.field(project, 'projectFolder'), 'nativePath') == Reflect.field(value[0], 'nativePath')) {
								projects.removeItem(project);
								updateTreeView();

								// in case of Close project we shall need to close the lang-server here
								// in case of Delete project this handles by the command class
								if (removalType == Std.string(FTETreeItemRenderer.CLOSE)) {
									dispatcher.dispatchEvent(new ProjectEvent(ProjectEvent.REMOVE_PROJECT, project));
								}
								break;
							}
						}
					});
		} else {
			for (fw_ in value) {
				var fw:FileWrapper = cast fw_;
				deleteFileWrapper = fw;
				proceedWithDeletionOfNode(fw);
			}
		}

		var proceedWithDeletionOfNode:FileWrapper->Void = function(value:FileWrapper):Void {
			// search through open projects as we don't know
			// which project the FileWrapper is belongs to
			for (fw in projectFolders) {
				parentCollection = findFilePosition(fw);
				if (parentCollection != null) {
					break;
				}
			}

			try {
				// this is a scenario when both parent and children
				// get selected and called for deletion
				parentCollection.splice(Lambda.indexOf(parentCollection, value), 1);
				if (AS3.as(lastSelectedItem, Bool) && lastSelectedItem == value) {
					tree.selectedItem = tree.getParentItem(value);
				}
			} catch (e:Error) {
				return;
			}

			fileCollection = null;
			updateTreeView();

			// check if the wrapper is the source folder to the project
			if (lastProcessedProjectPath != value.projectReference.path) {
				tmpProject = UtilsCore.getProjectFromProjectFolder(value);
			}
			if (tmpProject != null && (Std.is(tmpProject, AS3ProjectVO))) {
				if ((AS3.as(tmpProject, AS3ProjectVO)).sourceFolder.fileBridge.nativePath == value.nativePath) {
					(AS3.as(tmpProject, AS3ProjectVO)).sourceFolder = null;
				}
			}

			dispatcher.dispatchEvent(new TreeMenuItemEvent(TreeMenuItemEvent.FILE_DELETED, null, deleteFileWrapper));
		}
	}

	private function findFilePosition(value:FileWrapper):Array<Dynamic> {
		var tmpChildren:Array<Dynamic> = value.children;

		for (i in 0...tmpChildren.length) {
			if (tmpChildren[i] == deleteFileWrapper) {
				fileCollection = tmpChildren;
				return tmpChildren;
			}

			if (fileCollection != null) {
				return fileCollection;
			}
			if (AS3.as(Reflect.field(tmpChildren[i], 'children'), Bool) && (AS3.asArray(Reflect.field(tmpChildren[i], 'children'))).length > 0) {
				findFilePosition(tmpChildren[i]);
			}
		}

		return ((fileCollection != null)) ? fileCollection : null;
	}

	private function handleItemCreateCancel(event:TreeMenuItemEvent):Void {
		var isNewFolder:Bool;
		var tmpCurrentEditWrapper:FileWrapper = AS3.as(currentEditedItem.data, FileWrapper);
		isNewFolder = (tmpCurrentEditWrapper.file != null) ? false : true;

		var openItems:Dynamic = tree.openItems;

		// remove newly created folder if Escape pressed
		if (isNewFolder) {
			var tmpIndexToDelete:Int = AS3.int(Lambda.indexOf(creatingItemIn.children, tmpCurrentEditWrapper));
			if (tmpIndexToDelete != -1) {
				creatingItemIn.children.splice(tmpIndexToDelete, 1);
			}
		}

		creatingItemIn.updateChildren();
		tree.openItems = openItems;
		cleanupAfterCreate();
	}

	private function handleItemCreateEnd(event:TreeMenuItemEvent):Void {
		var isNewFolder:Bool;
		var tmpCurrentEditWrapper:FileWrapper = AS3.as(currentEditedItem.data, FileWrapper);
		isNewFolder = (tmpCurrentEditWrapper.file != null) ? false : true;

		if (isNewFolder) {
			tmpCurrentEditWrapper.file = new FileLocation();
			tmpCurrentEditWrapper.file.fileBridge.name = event.menuLabel;
			dispatcher.dispatchEvent(
					new AddFolderEvent(AddFolderEvent.ADD_NEW_FOLDER, tmpCurrentEditWrapper, creatingItemIn)
			);
		}
	}

	private function cleanupAfterCreate():Void {
		creatingItemIn = null;
		templateToCreate = null;
		tree.invalidateList();

		currentEditedItem.removeEventListener(TreeMenuItemEvent.EDIT_END, handleItemCreateEnd);
		currentEditedItem.removeEventListener(TreeMenuItemEvent.EDIT_CANCEL, handleItemCreateCancel);
	}

	/*
	Custom implementation of editing, instead of using mx:Trees builtin capabilities
	*/
	private function handleItemRenameCancel(event:TreeMenuItemEvent):Void {
		cleanupAfterRename();
	}

	private function handleItemRenameEnd(event:TreeMenuItemEvent):Void {
		if (AS3.as(ConstantsCoreVO.IS_AIR, Bool)) {
			performRename(event.data, event.menuLabel);
		} else {
			var tmpCurrentEditWrapper:FileWrapper = AS3.as(currentEditedItem.data, FileWrapper);
			var oldName:String = Std.string(tmpCurrentEditWrapper.file.fileBridge.name);
			tmpCurrentEditWrapper.file.fileBridge.name = event.menuLabel;
			dispatcher.dispatchEvent(
					new RenameFileFolderEvent(RenameFileFolderEvent.RENAME_FILE_FOLDER, tmpCurrentEditWrapper, oldName)
			);

			cleanupAfterRename();
		}
	}

	private function cleanupAfterRename():Void {
		tree.keyNav = true;
		currentEditedItem.removeEventListener(TreeMenuItemEvent.EDIT_END, handleItemRenameEnd);
		currentEditedItem.removeEventListener(TreeMenuItemEvent.EDIT_CANCEL, handleItemRenameCancel);
		currentEditedItem = null;
	}

	private function performRename(item:FileWrapper, newName:String):Void {
		var newFile:FileLocation = item.file.fileBridge.parent.resolvePath(newName);

		// in case of no modification of a currently edited item
		if (FileWrapper(currentEditedItem.data).file.fileBridge.nativePath == newFile.fileBridge.nativePath) {
			cleanupAfterRename();
			return;
		}

		if (AS3.as(newFile.fileBridge.exists, Bool)) {
			// re-do edit
			if (currentEditedItem != null) {
				tree.keyNav = false;
				tree.callLater(currentEditedItem.startEdit, [newName]);
				currentEditedItem.setErrorInEdit('Same package name is not allowed');
				return;
			}
		} else {
			cleanupAfterRename();
		}

		item.file.fileBridge.moveTo(newFile, false);
		item.file = newFile;

		refreshByWrapperItem(item);
	}

	private function fileDoubleClickedInTree(event:ListEvent):Void {
		var item:FileWrapper = AS3.as(tree.selectedItem, FileWrapper);
		if (AS3.as(tree.dataDescriptor.isBranch(item), Bool)) {
			refreshActiveProject(item);
			tree.expandItem(item, !tree.isItemOpen(item), true);
		} else {
			if (AS3.as(item.file.fileBridge.isDirectory, Bool) || item.isWorking) {
				return;
			}

			refreshActiveProject(item);
			dispatcher.dispatchEvent(
					new OpenFileEvent(OpenFileEvent.OPEN_FILE, cast [item.file], -1, cast [item])
			);
		}
	}

	private function getIconForFile(object:Dynamic):Class<Dynamic> {
		return null;
	}

	private function getTreeTooltip(item:Dynamic):String {
		if (!AS3.as(FileWrapper(item).isRoot, Bool)) {
			return null;
		}
		return Std.string(FileWrapper(item).file.fileBridge.nativePath);
	}

	private function refreshActiveProject(projectFileWrapper:FileWrapper):Void {
		if (projectFileWrapper == null) {
			return;
		}

		var activeProject:ProjectVO = UtilsCore.getProjectFromProjectFolder(projectFileWrapper);
		if (activeProject != null) {
			if (model.activeProject != activeProject) {
				model.activeProject = activeProject;
				if (Std.is(activeProject, AS3ProjectVO)) {
					UtilsCore.setProjectMenuType(AS3.as(activeProject, AS3ProjectVO));
				}

				dispatcher.dispatchEvent(new ProjectEvent(ProjectEvent.ACTIVE_PROJECT_CHANGED, activeProject));
			}
		}
	}

	private function onFileSingleClickedInTree(event:ListEvent):Void {
		refreshActiveProject(AS3.as(tree.selectedItem, FileWrapper));
	}

	private function onTreeItemOpen(event:TreeEvent):Void {
		tree.saveItemForOpen(event.item);
	}

	private function onTreeItemClose(event:TreeEvent):Void {
		tree.removeFromOpenedItems(event.item);
	}

	private function onScrollFromSource(event:Event):Void {
		dispatcher.dispatchEvent(new ProjectEvent(ProjectEvent.SCROLL_FROM_SOURCE));
	}

	//  end scripts

	//  supporting function definitions for properties, events, styles, effects
	/**
	 * @private
	 **/
	public function ___TreeView_VBox1_preinitialize(event:mx.events.FlexEvent):Void {
		onCreationCompletes();
	}

	/**
	 * @private
	 **/
	public function ___TreeView_VBox1_remove(event:mx.events.FlexEvent):Void {
		onRemoval();
	}

	/**
	 * @private
	 **/
	public function __header_scrollFromSource(event:flash.events.Event):Void {
		onScrollFromSource(event);
	}

	/**
	 * @private
	 **/
	public function __header_creationComplete(event:mx.events.FlexEvent):Void {
		initHeader();
	}

	/**
	 * @private
	 **/
	public function __tree_itemOpen(event:mx.events.TreeEvent):Void {
		onTreeItemOpen(event);
	}

	/**
	 * @private
	 **/
	public function __tree_itemClose(event:mx.events.TreeEvent):Void {
		onTreeItemClose(event);
	}

	/**
	 * @private
	 **/
	public function __tree_itemDoubleClick(event:mx.events.ListEvent):Void {
		fileDoubleClickedInTree(event);
	}

	/**
	 * @private
	 **/
	public function __tree_itemClick(event:mx.events.ListEvent):Void {
		onFileSingleClickedInTree(event);
	}

	/**
	 * @private
	 **/
	public function __tree_creationComplete(event:mx.events.FlexEvent):Void {
		initTree();
	}

	//  binding mgmt
	private function _TreeView_bindingsSetup():Array<Dynamic> {
		var result:Array<Dynamic> = [];

		result[0] = new mx.binding.Binding(this,
				null,
				null,
				'tree.dataProvider', 'projectFolders');

		result[1] = new mx.binding.Binding(this,
				function():Function {
					return (getIconForFile);
				},
				null,
				'tree.iconFunction');

		result[2] = new mx.binding.Binding(this,
				function():mx.core.IFactory {
					return (new ClassFactory(FTETreeItemRenderer));
				},
				null,
				'tree.itemRenderer');

		return result;
	}

	/**
	 * @private
	 **/
	public static var watcherSetupUtil(never, set):IWatcherSetupUtil2;
	private static function set_watcherSetupUtil(watcherSetupUtil:IWatcherSetupUtil2):IWatcherSetupUtil2 {
		(TreeView)._watcherSetupUtil = watcherSetupUtil;
		return watcherSetupUtil;
	}

	private static var _watcherSetupUtil:IWatcherSetupUtil2;

	//  embed carrier vars
	//  end embed carrier vars

	//  binding management vars
	/**
	 * @private
	 **/
	@:ns('mx_internal') private var _bindings:Array<Dynamic> = [];
	/**
	 * @private
	 **/
	@:ns('mx_internal') private var _watchers:Array<Dynamic> = [];
	/**
	 * @private
	 **/
	@:ns('mx_internal') private var _bindingsByDestination:Dynamic = {};
	/**
	 * @private
	 **/
	@:ns('mx_internal') private var _bindingsBeginWithWord:Dynamic = {};

}

//  end package def